#+LaTeX_HEADER:\usepackage[margin=2cm]{geometry}
#+LaTeX_HEADER:\usepackage{enumitem}
#+LaTeX_HEADER:\renewcommand{\ttdefault}{pcr}
#+LaTeX_HEADER:\lstdefinelanguage{yaml}{basicstyle=\ttfamily\scriptsize,frame=lrtb,framerule=1pt,framexleftmargin=1pt,showstringspaces=false}
#+LaTeX_HEADER:\usepackage{etoolbox}
#+LaTeX_HEADER:\makeatletter\patchcmd{\@verbatim}{\verbatim@font}{\verbatim@font\scriptsize}{}{}\makeatother
#+LATEX:\setitemize{noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt}
#+OPTIONS: toc:nil author:nil ^:nil

#+TITLE: L7MP: A programmable L7 meta-proxy

/[L7mp is currently under construction, with many advertised features untested, not working as promised, or completely missing.]/

L7mp is a programmable, multi-protocol service proxy optimized for
persistent, long-lived media streams and telco use cases:

- "L7", because the main unit of traffic is transport- and
  application-layer connections/sessions;
- "meta", because new protocols can be dynamically introduced on top
  of primitive protocols;
- "proxy", because it connects application-level traffic streams in a
  protocol-agnostic manner, e.g., you can pipe a UNIX domain socket to
  a WebSocket stream transparently and vice versa;
- and "programmable", because L7mp exposes a RESTful API that allows
  to query, manage, or modify data-plane streams.

L7mp is modeled after [[https://github.com/envoyproxy/envoy][Envoy]]
in that it uses similar abstractions (Listeners, Clusters, etc.), but
it also adds some new functionality to manage long-lived media
streams.  For instance, L7mp implements many protocols that Envoy does
not support natively, or does not support at all (e.g., UDP, raw IP,
L2), and provides an API to dynamically build new ones (VXLAN, RTP,
DNS, or ICMP) on top.  Furthermore, L7mp features an extended routing
API, which allows to transparently pipe sessions across diverse
protocol listeners and clusters, with automatic and transparent
protocol transformation (e.g., you can route a UDP listener or a raw
IP socket to a WebSocket cluster and everything should work as
expected), native support for datagram- and byte-streams, stream
multiplexing/demultiplexing, encap/decap, etc.  Considering this
strong emphasis on multiprotocol support, L7mp may actually be closer
in nature to =socat(1)= than to Envoy, but it is dynamically
configurable through a REST API in contrast to =socat(1)= which is a
static CLI tool (but it is much more feature-complete than L7mp in
return).

The REST API is likewise similar to
[[https://github.com/cncf/udpa][Envoy/xDS]] with some useful
additions, like support for listing, killing, and dynamically
re-routing(!) individual transport sessions.

L7mp is written in Javascript/Node.js. This way, it is much simpler
and easier to extend than Envoy or =socat=, but at the same time it is
also much slower. We envision L7mp as an incubator and a testbed for a
set of useful extensions which should eventually be implemented into
one of those faster proxies.

* Installation

The below should eventually work fine, once L7mp gets open-sourced.

#+BEGIN_SRC sh
npm install l7mp --save
#+END_SRC

Until then, use the enclosed Dockerfile to deploy L7mp. At least
Node.js v12 is needed for correct UDP/connect support.

* Usage example

** Run

Run L7mp locally with a [[https://github.com/rg0now/l7mp/blob/master/config/l7mp-simple.yaml][sample]] static configuration.

#+BEGIN_SRC sh
node l7mp.js -c config/l7mp-simple.yaml -l warn
#+END_SRC

Configuration is accepted either in YAML format (if the extension is
=.yaml=) or JSON (otherwise).  Command line arguments override static
configuration parameters.

** Query configuration

The sample configuration will fire up a HTTP listener at port 1234 and
route it to the L7mp controller that serves the L7mp REST API.

Test API access. This will dump the full current configuration back in json:

#+BEGIN_SRC sh
curl http://localhost:1234/api/v1/config
#+END_SRC

** Manage sessions

Observe that, on top of the static configuration, the response
contains a new =sessions= object that lists the set of active
(connected) live sessions in L7mp.  You can list the live sessions
explicitly.

#+BEGIN_SRC sh
curl http://localhost:1234/api/v1/sessions
#+END_SRC

The session was created by L7mp because the static configuration
installs a UDP listener and connects it to a specified remote peer
(=UDPSigletonListener=), and this Listener immediately generates a new
session. You can delete this session (suppose its name is
=session-name=) via the below REST API call.

#+BEGIN_SRC sh
curl -iX DELETE http://localhost:1234/api/v1/sessions/<session-name>
#+END_SRC

** Add a new cluster

Add a new UDP cluster named =user-1-2-c= that will connect to the
endpoint at =localhost:16000=, and bind this cluster locally to port
16001.

#+BEGIN_SRC sh
curl -iX POST --header 'Content-Type:text/x-yaml' --data-binary @- <<EOF  http://localhost:1234/api/v1/clusters
cluster:
  name: user-1-2-c
  spec: { protocol: "UDP", port: 16000, bind: { address: '127.0.0.1', port: 16001 } }
  endpoints:
    - spec: { address:  "127.0.0.1" }
EOF
#+END_SRC

Note that the REST API accepts both JSON and YAML configs (YAML will
be converted to JSON internally). If multiple endpoints are added,
L7mp will load-balance among these (TODO, currently only the =trivial=
load balancer is implemented that routes everything to the first
endpoint).

** Add a new listener with a route

Now add a new UDP listener called =user-1-2-l= at port 15000 that will
immediately connect back to =127.0.0.1:15001= and route it to the
cluster we have just created (named =user-1-2-c=).

#+BEGIN_SRC sh
curl -iX POST --header 'Content-Type:text/x-yaml' --data-binary @- <<EOF  http://localhost:1234/api/v1/listeners
listener:
  name: user-1-2-l
  spec: { protocol: UDP, port: 15000, connect: {address: "127.0.0.1", port: 15001} }
  rules:
    - action:
        route:
          cluster: user-1-2-c
          ingress:
            - up
        retries: { attempts: 200, perTryTimeout: 1000 }
EOF
#+END_SRC

There is an important quirk here, namely that the ingress route
contains a Transformer cluster called =up=; this cluster has been
specified statically in the sample configuration file to connect to
the remote server =ws://localhost:8080=.

** Routing

On session creation, L7mp will demultiplex the bidirectional stream at
the listener into two uni-directional streams: the /ingress stream/
(in the direction from the listener to the cluster) will be routed
through the WebSocket cluster =up=, which may then readily transform
the stream and send the results back.  The returned stream is then
piped to the cluster =user-1-2-c=.  In the /egress direction/ (from
the cluster back to the listener), no transformation occurs.

The ingress and the egress routes are specified and handled
separately.  Both routes can contain a list of any number of Transform
clusters that will be chained sequentially, automatically performing
transparent protocol and payload conversion along the way. Note that
datagram boundaries are preserved during transformation whenever
possible, and when it is not (i.e., piping a UDP stream to a TCP
cluster will lose segmentation), L7mp issues a warning.

This should yield the routes:

: ingress: user-1-2-l -> up -> user-1-2-c
: egress:  user-1-2-c -> user-1-2-l

** Retries and timeouts

[TODO]

When created, the UDP listener immediately becomes connected (to avoid
this behavior, do not specify a =connect= clause in the spec, TODO),
creates a session, and then tries to route the session through the
=up= cluster by properly piping the underlying streams.  In the
current configuration, this will fail because no one is listening on
the other side.

As per the =retries= setting in the route, L7mp will automatically
retry the connection at most 200 times, waiting each time 1000 ms for
the stream to be successfully established.

** Test the connection

To complete the connection, fire up a
[[https://github.com/vi/websocat][websocat]] echo server on
=localhost:8080=:

#+BEGIN_SRC sh
websocat -v -v -v -v -v ws-l:0.0.0.0:8080 mirror:
#+END_SRC

Start a =socat= sender (don't forget to bind the sender to 5555,
otherwise L7mp, which connects back to this port, will not accept the
connection):

#+BEGIN_SRC sh
socat - udp:localhost:15000,sourceport=15001
#+END_SRC

Then, start a =socat= receiver:

#+BEGIN_SRC sh
socat udp-l:16000 -
#+END_SRC

What you type in the sender should appear transparently at the
receiver and =websocat= should report something like =incoming text=,
indicating that the =up= cluster received our input. In the reverse
direction, however, no such report should appear.

** Clean up

Provided that the new session is named =session-name= (L7mp
automatically assigns unique names to each session, you can check this
by issuing a GET request to the API endpoint
=/api/v1/sessions/{session-name}=), you can delete the session, the
cluster and the listener as follows:

#+BEGIN_SRC sh
curl -iX DELETE http://localhost:1234/api/v1/sessions/<session-name>
curl -iX DELETE http://localhost:1234/api/v1/listeners/user-1-2-l
curl -iX DELETE http://localhost:1234/api/v1/clusters/user-1-2-c
#+END_SRC

* Protocol support

|---------------+-------------------+------------------+-------+-----------+-------------+----------|
| Protocol      | Session ID        | Type             | Role  | Mode      | Re/To/Lb    | Status   |
|---------------+-------------------+------------------+-------+-----------+-------------+----------|
| UDP-singleton | IP 5-tuple        | datagram         | l/c/t | singleton | no/yes/yes  | Full     |
| UDP-server    | IP 5-tuple        | datagram         | l     | server    | no/yes/yes  | TODO     |
| TCP           | IP 5-tuple        | stream           | l/c/t | server    | yes/yes/yes | TODO     |
| HTTP          | IP 5-tuple        | session          | l/c/t | server    | yes/yes/yes | Listener |
| WS            | IP 5-tuple + HTTP | datagram         | l/c/t | server    | yes/yes/yes | Full     |
| STDIO-fork    | N/A               | stream/session   | t     | singleton | no/no/no    | TODO     |
| UNIX/stream   | file desc/path    | stream           | l/c/t | server    | no/no/no    | Untested |
| UNIX/dgram    | file desc/path    | datagram/session | l/c/t | singleton | no/no/no    | Untested |
| PIPE          | file desc/path    | stream           | l/c/t | singleton | no/no/no    | TODO     |
| AF_PACKET     | file desc         | datagram         | l/c/t | singleton | no/no/no    | TODO     |
| PORT          | tun/tap/port      | datagram         | l/c/t | singleton | no/no/no    | TODO     |
| INLINE/stream | N/A               | stream           | t     | singleton | no/no/no    | TODO     |
| INLINE/dgram  | N/A               | datagram         | t     | singleton | no/no/no    | TODO     |
| INLINE/STDIO  | N/A               | stream/session   | c     | singleton | no/no/no    | Full     |
| INLINE/Echo   | N/A               | stream/session   | t/c   | singleton | no/no/no    | Full     |
| INLINE/Logger | N/A               | stream/session   | t/c   | singleton | no/no/no    | Full     |
|---------------+-------------------+------------------+-------+-----------+-------------+----------|

** Protocols

- UDP-singleton is a "connected" UDP server, while UDP-server is a
  listener-only protocol that emits a new session for each IP
  5-tuple
- STDIO-fork is a (transform-only) protocol for communicating with a
  forked process through STDIO/STDOUT
- Inline/STDIO pipes the stream to the L7mp proxy stdin/stdout, stream
  reads from stdin and write to stdout (useful for debugging)
- Inline/Echo is an Echo Cluster, writes back everything it reads
  (useful for debugging)
- Inline/Logger is also an Echo Cluster, but also writes everything
  that goes through it to a file (useful for debugging)
- INLINE/stream and INLINE/dgram are transforms-only protocols for
  built-in transformers (node-js Transform objects)

** Session id

A unique name/descriptor for a session, generated dynamically by the
protocol's listener.

** Type

- session: receives/rewrites session metadata, called at session-setup
  time
- stream: byte-stream, segmentation/message boundaries not preserved
- datagram: datagram-stream segmentation/message boundaries preserved

Note that streams can run on top of datagram protocols but not the
other way around (warn!)

** Mode

- server: listen+accept -> new session
- singleton: can emit a single session only

** Role

- listener (l): protocol supports listeners to emit sessions
- cluster (c): protocol supports clusters to forward sessions to
- transform (t): bump-in-the-wire transformation of session
  metadata or payload (stream/datagram)

** Re/To/Lb

- Re: Retries support, To: Timeout support, Lb: load-balance support

** Status

* Documentation

- [[https://github.com/rg0now/l7mp/blob/master/openapi/README.md][API model]] and the REST API
  [[https://github.com/rg0now/l7mp/blob/master/openapi/index.html][endpoints]]
- Main [[https://github.com/rg0now/l7mp/blob/master/openapi/README.md][concepts]]


* Examples

** Example 1: HTTP3/QUIC Gateway to Kubernetes/Istio

*** Objective

- ingress gateway that translates QUIC calls from the
- NB: HTTP3/QUIC support is TODO

*** TODO Pipeline

*** Config

- static config
#+BEGIN_SRC yaml
  admin:
    log_level: info
    log_file: /tmp/l7mp.log
    access_log_path: /tmp/admin_access.log
  listeners:
    - name: monitor_listener
      spec: { protocol: HTTP, port: 1235 }
      rules:
        - action:
            route:
              cluster: monitor_responder
    - name: http3_listener
      spec: { protocol: HTTP3, port: 443 }
      rules:
        - match:
            HTTP:
              path:
                prefix: "auth/"
          action:
            route:
              cluster: auth
        - action:
            route:
              cluster: frontend
  clusters:
    - name: monitor_responder
      spec: { protocol: PROMETHEUS }
    - name: auth
      spec: { protocol: HTTP, port: 8888 }
      endpoints:
        spec: { address: "auth.default.svc.cluster.local" }
    - name: frontend
      spec: { protocol: HTTP, port: 80 }
      endpoints:
        spec: { address: "nginx.default.svc.cluster.local" }
#+END_SRC

** Example 2: REST Converter

*** Objective

- push reports (e.g., from an IoT device) received on UDP into the
  cluster as REST API calls
- NB: UDP_server support is TODO

*** TODO Pipeline

*** Config

- static config
#+BEGIN_SRC yaml
  admin:
    log_level: info
    log_file: /tmp/l7mp.log
    access_log_path: /tmp/admin_access.log
  listeners:
    - name: monitor_listener
      spec: { protocol: HTTP, port: 1235 }
      rules:
        - action:
            route:
              cluster: monitor_responder
    - name: udp_listener
      spec: { protocol: UDP_server, port: 999 }
      rules:
        - action:
            metadata:
              HTTP:
                method: POST
                url:
                  path: "/topics/jsontest"
                headers:
                  content_type: "application/vnd.kafka.json.v2+json"
            route:
              cluster: kafka
              ingress:
                - http_set
                - json_encap
  clusters:
    - name: monitor_responder
      protocol: PROMETHEUS
    - name: kafka_rest
      spec: { protocol: HTTP, port: 8888 }
      endpoints:
        spec: { dest: "auth.default.svc.cluster.local" }
  transforms:
    - name: json_encap
      type: JSON_ENCAP # built-in (datagram-type)
#+END_SRC

** Example 3: SIP/RTP Media Plane

*** Objective

- process VoIP calls as RTP streams in Kubernetes/Istio

*** Pipeline

:              UNIX/dgram        WS: 8888          UNIX/dgram
:              ingress:up      transcode:up       egress: down
:                 A |               A |               A |
:  +----------+   | |               | |               | |   +------------------+
:  |          |---+ +---------------+ +---------------+ +-->|                  |
:  |UDP-l:1234|                                             |UDP-c:1.1.1.1/4321|
:  |          |<--+ +---------------+ +---------------+ +---|                  |
:  +----------+   | |               | |               | |   +------------------+
:                 | V               | V               | V
:             UNIX/dgram         WS: 8888          UNIX/dgram
:             egress:down     transcode:down      ingress:down

*** Config

- static config
#+BEGIN_SRC yaml
  admin:
    log_level: debug
    log_file: stdout
    access_log_path: /tmp/admin_access.log
  listeners:
    - name: controller_listener
      spec: { protocol: HTTP, port: 1234 }
      rules:
        - action:
            route:
              cluster: controller   # northbound: predefined INLINE/stream
    - name: monitor_listener
      spec: { protocol: HTTP, port: 1235 }
      rules:
        - action:
            route:
              cluster: monitor_responder   # predefined INLINE/stream
  clusters:
    - name: controller
      spec: { protocol: L7MPController }
    - name: monitor_responder
      spec: { protocol: PROMETHEUS }
    - name: "drop"
      spec: { protocol: DROP }
    - name: "ingress:up"
      spec: { protocol: UNIX }
      endpoints:
        - spec: { path: "/tmp/ingress_up.sock" }
    - name: "egress:up"
      spec: { protocol: UNIX }
      endpoints:
        - spec: { path: "/tmp/egress_up.sock" }
    - name: "ingress:down"
      spec: { protocol: UNIX }
      endpoints:
        - spec: { path: "/tmp/ingress_down.sock" }
    - name: "egress:down"
      spec: { protocol: UNIX }
      endpoints:
        - spec: { path: "/tmp//egress_down.sock" }
    - name: "transcode:up"
      spec: { protocol: WS, port: 8888 }
      endpoints:
        - spec: { address: "transcode1.default.svc.cluster.local" }
    - name: "transcode:down"
      spec: { protocol: WS, port: 8888 }
      endpoints:
        - spec: { address: "transcode2.default.svc.cluster.local" }
#+END_SRC

- adding a session: A: 1.2.3.4:5000 -> B: 4.3.2.1:5001
#+BEGIN_SRC yaml
  listeners:
    - name: user_1_2_l
      spec: { protocol: UDP, port: 5000, connect: {address: "1.2.3.4", port: 5000} }
      rules:
        - action:
            route:
              cluster: user_1_2_c
              ingress:
                - "ingress:up"   # demo: manually add a transform
                - "transcode:up" # automatically creates a transform for cluster
                - "egress:up"    # automatically creates a transform for cluster
              egress:
                - "ingress:down"   # automatically creates a transform for cluster
                - "transcode:down" # automatically creates a transform for cluster
                - "egress:down"    # automatically creates a transform for cluster
  clusters:
    - name: user_1_2_c
      spec: { protocol: UDP, port: 5001, bind: {port: 5001} }
      endpoints:
        - spec: { address: "4.3.2.1" }
  transforms:
    - name: "ingress:up"
      type: CLUSTER
      params:
        cluster: "ingress:up"
#+END_SRC

** TODO Example 4: Istio

* License

Copyright 2019 by its authors.
Some rights reserved. See AUTHORS.

MIT License
